# SchematronMD

This repository contains a Velocity template to be used with the MagicDraw Report Wizard to generate a [Schematron](http://schematron.com/) ruleset.

## The ruleset

The rules generated by the VTL template protect against a class of syntactic errors relating to the use of the `xsd:ID`, `xsd:IDREF` and `xsd:IDREFS` data types.

The use of `xsd:ID` types are used in the Cast Vote Records and Election Results Reporting common data formats conserve storage space. For example, it would be inefficient to repeat details about the a particular contest in an instance containing multiple CVRs with that contest.

Instead reusable data is defined once and referenced when needed. However, a problem arises when the UML Model is converted to a concrete format such as XML Schema. The `xsd:ID` type is opaque, meaning it conveys no details about the type it refers. Thus, the XML Schema cannot enforce the "wiring" of `xsd:ID` to and from `xsd:IDREF` and `xsd:IDREFS`.

The VTL template automatically generates rules enforcing the types that can appear on either end of a directed association.

## Example

Consider the type `Candidate`. It has an element `PartyId` to associate a candidate to one or more political parties. A schematron rule enforcing this relationship is given below:

```xml
<sch:rule context="element(*, err:Candidate)">
    <sch:assert test="not(id(err:PartyId)[not(. instance of element(*, err:Party))])">PartyId (<xsl:value-of select="err:PartyId" />) must point to an element of type Party</sch:assert>
</sch:rule>
```

`id(err:PartyId)` uses the XPath `id` function to return the element containing that `id`. It should be a type of `Party`! The predicate in the brackets `. instance of element(*, err:Party)` checks exactly that.

> The use of `not` in the above example at first glance appears confusing. For the rule to validate, it must not return any elements (an empty sequence casts to the boolean value of `false`). Thus we also negate the predicate, that it only returns an element when the instance is not of the desired type. Because we could potentially list multiple `xsd:ID` in an `XSD:IDREFS`, we cannot test the positive case without knowing the exact number expected, which cannot be done at compile time.