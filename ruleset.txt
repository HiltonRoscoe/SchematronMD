#import('hrsort', 'com.hiltonroscoe.mdreportext.Sorter')
#set($packages = $array.createArray())
#set($void = $array.addCollection($packages, $Package))
#set($void = $array.addCollection($packages, $SmartPackage))
#foreach ($package in $sorter.sort($packages, "qualifiedName"))
#set($qualifiedName = $package.qualifiedName)
#set ($classList = $array.createArray())
#foreach ($element in $report.getOwnedElementsIncludingAdditional($package, true))
#if ($element.elementType == "class")
#set ($void = $classList.add($element))
#end
#end
#end
## BEGIN MACROS ##
## RECURSIVELY CALLS ITSELF UNTIL THE ROOT IS FOUND ##
#macro( rootWalk $input, $path)
#set ($void = $path.add($input.name))
#if(!$report.getAppliedStereotypeByName($input, "Root"))
#set($relationList = $report.getRelationship($input))
#foreach ($rel in $relationList)
## ONLY WANT ASSOCIATIONS **
#if($rel.humanType == 'Association')
## DO NOT REMOVE, WORKAROUND FOR A BUG THAT CAUSES $input to BE **
## REDEFINED!! **
#set($inputName = $input.name)
#foreach($relEnd in $rel.memberEnd)
#if($relEnd.aggregation == "composite")
#if($relEnd.owner.name != $inputName && $relEnd.owner.humanType == 'Class')
#rootWalk( $relEnd.owner, $path)
#end
#end
#end
#end
#end
#end
#end
## END MACROS **
#foreach ($class in $sorter.sort($classList))
#set($relationList = $report.getRelationship($class))
#set($void = $group.init())
#foreach ($relation in $relationList)
#set($void = $group.put($relation.humanType, $relation))
#end
#set($xPathExprs = $array.createArray())
#if (!$relationList.isEmpty())
#foreach ($key in $sorter.sort($group.groupNames()))
#foreach($rel in $sorter.sort($group.get($key)))
## ONLY WANT ASSOCIATIONS **
#if($rel.humanType == 'Association')
## RESET FOR NEXT IERATION **
#set($roleName = "")
#set($isNav = false)
#set($aggregation = false)
#set($plural = false)
#foreach($relEnd in $rel.memberEnd)
## GET THE ROLE NAME, IF ANY **
#if($relEnd.type == $class)#set($roleName = $relEnd.name)#end
#if($relEnd.aggregation == "composite")#set($aggregation = true)#end
#if($relEnd.upperValue.value == -1 || $relEnd.upperValue.value > 1)#set($plural = true)#end
## CHECK IF WE HAVE A NAVIGABLE END FROM OTHER SIDE **
#if($relEnd.owner != $class && $relEnd.owner.humanType == 'Class')
#set($isNav = true)
#end
## END FOR EACH **
#end
## END ASSOCIATION ** 
#end
#if(!$aggregation)
#foreach($re in $sorter.sort($rel.relatedElement))
## DONT GET THE ONE THAT IS THE CURRENT CLASS **
#if($re != $class && $isNav)
#if($plural)#set($suffix = "Ids")#else#set($suffix = "Id")#end
#set($refId = $roleName + $suffix)
#set($void = $xPathExprs.add("name() = '$refId' and #if($list.size($re.superClass) > 0)string(../@xsi:type) = '$re.name'#else../name() = '$re.name'#end"))
#end
#end
#end
#end
#end
## TODO CHECK WE GOT ANY EX PR **
#set($path = $array.createArray())
#rootWalk($class, $path)
#set($void = $hrsort.reverse($path))
## ONLY OUTPUT WHEN WE HAVE AT LEAST ONE EXPR **
#if(!$xPathExprs.isEmpty())
<sch:rule context="#foreach($pathPart in $path)err:$pathPart#if(!$foreach.last)/#end#end">
    <sch:assert test="count(idref(current()/@ObjectId)[#foreach($expr in $xPathExprs)($expr)#if(!$foreach.last) or #end#end]) > 0">$path must have refereant from $xPathExprs</sch:assert>
</sch:rule>
#end
#end
#end